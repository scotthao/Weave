<?xml version="1.0" encoding="utf-8"?>
<!--
/*
Weave (Web-based Analysis and Visualization Environment)
Copyright (C) 2008-2011 University of Massachusetts Lowell

This file is a part of Weave.

Weave is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License, Version 3,
as published by the Free Software Foundation.

Weave is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Weave.  If not, see <http://www.gnu.org/licenses/>.
*/
-->

<!---
@author fkamayou
@author mervetuccar
@author hgranz
@spurushe
-->

<mx:VBox xmlns:mx="http://www.adobe.com/2006/mxml" width="400" height="300"		 
		 xmlns="weave.editors.*"
		 xmlns:ui="weave.ui.*"
		 label="Disability"
		 implements="weave.api.core.ILinkableObject"
		 enabled="{_panel != null}" xmlns:s="library://ns.adobe.com/flex/spark"	>
	
	<mx:Label text="User generated visualization description text:"
			  textAlign="left"/>
	
	<mx:TextArea id="manualToolDescTextBox" 
				 width="100%" 
				 height="40%" 
				 minWidth="5" 
				 minHeight="5"
				 borderStyle="solid" 
				 editable="true"  
				 keyFocusChange="event.preventDefault(); event.target.replaceSelectedText('\t');"
				 toolTip="changeme"
				 creationComplete="handleCreationComplete(event);" 
				 wordWrap="true"/>
	
	<mx:Label text="System generated visualization description text:"
			  textAlign="left"/>
	
	<mx:TextArea id="automaticToolDescTextBox" 
				 width="100%" 
				 height="40%" 
				 minWidth="5" 
				 minHeight="5"
				 borderStyle="solid" 
				 editable="false"  
				 keyFocusChange="event.preventDefault(); event.target.replaceSelectedText('\t');"
				 toolTip="changeme"
				 wordWrap="true" text=""/>
	
	<mx:Button label="Refresh Description"
			   id="automaticDescRefreshButton" 
			   toolTip="changeme" click="automaticDescRefreshButton_clickHandler(event)"/>

	
	
	<mx:Script>
		<![CDATA[
			import disabilityDictionary.DisabilityMessageCategoryDictionary;
			import disabilityDictionary.DisabilityMessageProperties;
			import disabilityDictionary.DisabilityObject;
			
			import mx.accessibility.CheckBoxAccImpl;
			import mx.binding.utils.BindingUtils;
			import mx.controls.Alert;
			import mx.controls.Menu;
			import mx.controls.TextArea;
			import mx.core.IUIComponent;
			import mx.core.UIComponent;
			import mx.events.DragEvent;
			import mx.events.FlexEvent;
			import mx.managers.DragManager;
			import mx.rpc.AsyncToken;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			
			import weave.Weave;
			import weave.api.WeaveAPI;
			import weave.api.core.ILinkableObject;
			import weave.api.data.IAttributeColumn;
			import weave.api.linkBindableProperty;
			import weave.api.newLinkableChild;
			import weave.api.registerLinkableChild;
			import weave.api.reportError;
			import weave.api.setSessionState;
			import weave.api.ui.ILinkableObjectEditor;
			import weave.api.unlinkBindableProperty;
			import weave.api.unlinkSessionState;
			import weave.core.LinkableHashMap;
			import weave.core.LinkableString;
			import weave.data.KeySets.KeySet;
			import weave.services.DelayedAsyncInvocation;
			import weave.services.DelayedAsyncResponder;
			import weave.services.WeaveRServlet;
			import weave.services.beans.RResult;
			import weave.ui.ControlPanel;
			import weave.ui.DisabilityOptions;
			import weave.ui.DraggablePanel;
			import weave.utils.ColumnUtils;
			import weave.utils.LinkableTextFormat;
			import weave.visualization.plotters.ParallelCoordinatesPlotter;
			import weave.visualization.tools.LineChartTool;
			
			
			
			[Bindable] private var _panel:DraggablePanel = null;

			
			public var vizEntities:Array = WeaveAPI.globalHashMap.getObjects(LineChartTool);//collect all the visualization tools
			public var _target:LineChartTool = vizEntities[0] as LineChartTool;;// = Weave.root.requestObject(null, LineChartTool, false);
		
			public var lineChartPlotter:ParallelCoordinatesPlotter = (vizEntities[0] as LineChartTool).getPlotter();
			

			public var variables:LinkableHashMap; 

			public var Rservice:WeaveRServlet = new WeaveRServlet(Weave.properties.rServiceURL.value);
			
			//public var joinedColsforRArrayUnsplit:Array = new Array();
			public const disabilityText:LinkableString = newLinkableChild(this, LinkableString);
			public var joinKeysRArray:Array = new Array();
			public var joinColsRArray:Array = new Array();
			public var columnNames:Array = new Array();
			
			public function set target(panel:DraggablePanel):void
			{
				if (_panel)
					throw new Error("target should not be set more than once");
				
				_panel = panel;
			}
			
			override protected function childrenCreated():void
			{
				super.childrenCreated();
				
			}
			
			public function getSystemGeneratedText():void
			{
			}
		
			private function handleCreationComplete(event:Event) : void
			{
				variables = lineChartPlotter.columns;
				checkingPlotterObjects();
				variables.childListCallbacks.addImmediateCallback(this,checkingPlotterObjects);
				Weave.properties.disabilityHashMap.requestObject('text', LinkableString, false);
				var HashDisabilityText : LinkableString = (Weave.properties.disabilityHashMap.renameObject('text', _panel.title) as LinkableString);
				
				if( HashDisabilityText == null)
					reportError("Error Creating request object from Disability Options");
				else
					linkBindableProperty(HashDisabilityText, event.target, "text");
				
			}
			
			protected function automaticDescRefreshButton_clickHandler(event:MouseEvent):void
			{
				automaticToolDescTextBox.text = "after button clicked";
				var dictionaryType:String;
				var vizType:String;
				var rResult:Array;
		//		rResult = getInfoForR(/*columns???*/);
				vizType = "lineChart";

			}
			
			//this function checks if the hashmap of the plotter is filled, if filled pick columns and send them to R
			public function checkingPlotterObjects():void{
				
				if(WeaveAPI.SessionManager.linkableObjectIsBusy(variables)) return;
				columnPreprocessing();
			}
			
			//getting the columns ready for R
			protected function columnPreprocessing():void
			{
				//use this function to gather the appropriate information that will be sent to R 
				//we have the columns in columnObjects
				var numericCols:Array = new Array();
				//below whatever cols are plotted it picks them up as individual objects

				var colObjects:Array = variables.getObjects(IAttributeColumn)
					
					//pick only numeric columns to be sent to R
					for(var i:int =0 ; i < colObjects.length; i++)
					{
						var col:IAttributeColumn = (colObjects[i] as IAttributeColumn);
						var dataType:String = ColumnUtils.getDataType(col);
						
						if (dataType == "number")
						{
							numericCols.push(col);
							columnNames.push(ColumnUtils.getTitle(col));
						}
					}
					
					
				//joining columns returns columns only complete records (no incomplete records)
			    var joinedColumns:Array = joinColumns(numericCols);
				
				joinKeysRArray = joinedColumns[0]; 
				joinColsRArray = joinedColumns[1];
			
				//todo: getting axis, title, color, scale, etc
				sendColumnsToR();
				
			
				
			}
			private function joinColumns(columns:Array):Array
			{
				var selection:KeySet = Weave.defaultSelectionKeySet;
				var keys:Array = selection.keys.length > 0 ? selection.keys : null;
				//make dataype Null, so that columns will be sent as exact dataype to R
				//if mentioned as String or NUmber ,will convert all columns to String or Number .
				var result:Array = ColumnUtils.joinColumns(columns,null, false, keys);
				return [result.shift(), result];
			}

			protected function sendColumnsToR():void
			{
				//send the columns and variables returned from getInfoForR to R using this function
				
				var computeScript:String = "mySlope <- y2 -y1";
				//inputValues is a matrix of all of the columns that are to be sent to R
				
				var inputValues:Array = new Array();
				var tempArray:Array = new Array();
				
				for (var i:int = 0; i<joinColsRArray.length; i++){
					inputValues.push(joinColsRArray[i][0].valueOf());
				}
			
			/* for(var j:int = 0; j < 	joinColsRArray.length; j++)
			{
				for(var i :int = 0; i < joinColsRArray[j].length; i++)
				{
					inputValues.push(joinColsRArray[j][1]);
				}
				
			} */
				
			    //inputValues = joinColsRArray; //use this
				var outputNames:Array = ["mySlope"];
				//default name to be used in R
				var inputName:Array = ["y1", "y2"];
				
				 var query:AsyncToken = Rservice.runScript(joinKeysRArray, inputName, inputValues, outputNames, computeScript, "", false, false, false);
				DelayedAsyncResponder.addResponder(query, handleRunScriptResult, handleRunScriptFault, joinKeysRArray);	 
				
			}
			public function handleRunScriptResult(event:ResultEvent, token:Object):void
			{
				//if (token != latestjoinedColumnKeys){return;}//handles two asynchronous calls made one after the other
				// to do handle multiple asynchronous calls
				var rObject:Array = new Array();
				rObject = event.result as Array;
				var finalRObject:Array = new Array();//collects all the RResult objects after being returned from R
				
				if (rObject == null){ 
					reportError("R Servlet did not return an Array of results as expected.");
					return;
				}
				
				for (var i:int=0; i < rObject.length; i++)
				{
					
					if (rObject[i] == null)
					{
						trace("WARNING! R Service returned null in results array at index "+i);
						continue;
					}
					
					var rResult:RResult = new RResult(rObject[i]);
					finalRObject[i] = rResult.value;
			
				}
				
				processingRResult(finalRObject);
			
			}
			private function handleRunScriptFault(event:FaultEvent, token:Object):void
			{
				trace(["fault", token, event.message].join("\n"));
				reportError(event);
			}
			
			public var checkLookUpDict:DisabilityMessageCategoryDictionary = new DisabilityMessageCategoryDictionary();
			
			public function processingRResult(_sentpropertiesValues:Array):void
			{
				//var mockSlope : Number = 1;
				var tempProperties:Array = new Array();
				//var mockpropertiesValues:Array = new Array();//array of values of properties returned from R
				tempProperties.push(_sentpropertiesValues);//returned from R
				
				//one DisabilityObject is made for every tool is one Weave instance
			    var tempDisabilityObject :DisabilityObject = new DisabilityObject();
				tempDisabilityObject.properties = _sentpropertiesValues;
				/* structure for vizDetails                 title
														   Attributes */
				tempDisabilityObject.vizDetails.push(_target.title);
				tempDisabilityObject.vizDetails.push(columnNames);
				
				//this gives us the final array of text messages
				var finalTextMessages:Array = checkLookUpDict.collectMessageCategoryID(tempDisabilityObject);
				automaticToolDescTextBox.text = finalTextMessages[0];
			}
			
		]]>
	</mx:Script>
</mx:VBox>
